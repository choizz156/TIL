## Process Synchronization
 - 공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있다.
 - 일관성 우지를 위해서는 협력 ㅡ로세스 간의 실행 순서를 정해주는 메커니즘이 필요하다.
## 데이터 접근
스토리지 박스(s-box)와 실행 박스(e-box)가 있다고 가정할 때 스토리지 박스에서 연산할 데이터를 실행 박스에 전달하면 실행 박스에서 연산한 후 그 결과를 다시 스토리지 박스에 저장한다.

![](/picture/데이터.jpg)
## Race Condition
- 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황.
- 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐. 
- race condition을 막기 위해서는 **동시에 작동하는 프로세스는 동기화되어야 한다.**

### 운영체제에서 race condition은 언제 발생하는가?

1. kernel 수행 중 인터럽트 발생 시
    
       - 커널모드 수행 중 인터럽트가 발생하여 인터럽트 처리루틴이 수행됨(둘 다 커널의 코드 이므로 커널 주소 공간 공유).
    `solution` : 커널 수행 동안에는 인터럽트를 못하게 한다. 
 
2. process가 시스템 콜을 하여 커널 모드로 수행 중인데 context switch가 일어난 경우
         
        - 두 프로세스 간의 주소 공간 간에는 데이터 공유가 없음.
        - 하지만 한 프로세스가 시스템 콜을 하여 커널이 수행을 하는 도중 time quantum이 끝나서 다른 프로세스로 cpu가 옮겨감.
        - 결국 다른 프로세스가 커널 주소 공간의 data에 접근하게 됨.
        - 이러면서 race condition이 발생 함.
        
    `solution` : 커널 모드에서 수행 중일 때는 cpu를 preempt하지 않음. 커널 모드에서 사용자 모드로 돌아갈때 preempt함.

3. multiprocessor에서 shared memory 내의 kernel data에서  

        어떤 cpu가 마지막으로 데이터를 저장했는지의 문제로 race condtion이 발생함.
    `solution` : 
    1. 한번에 하나의 cpu만이 커널에 들어갈 수 있게 한다. 
    2. 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlockd을 하는 방법
## The Critical Section Problem
- n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 `critical section`이 존재
- 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.
