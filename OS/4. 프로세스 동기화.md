## Process Synchronization
 - 공유 데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있다.
 - 일관성 우지를 위해서는 협력 ㅡ로세스 간의 실행 순서를 정해주는 메커니즘이 필요하다.
## 데이터 접근
스토리지 박스(s-box)와 실행 박스(e-box)가 있다고 가정할 때 스토리지 박스에서 연산할 데이터를 실행 박스에 전달하면 실행 박스에서 연산한 후 그 결과를 다시 스토리지 박스에 저장한다.

![](/picture/데이터.jpg)
## Race Condition
- 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황.
- 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐. 
- race condition을 막기 위해서는 **동시에 작동하는 프로세스는 동기화되어야 한다.**

### 운영체제에서 race condition은 언제 발생하는가?

1. kernel 수행 중 인터럽트 발생 시
    
       - 커널모드 수행 중 인터럽트가 발생하여 인터럽트 처리루틴이 수행됨(둘 다 커널의 코드 이므로 커널 주소 공간 공유).
    `solution` : 커널 수행 동안에는 인터럽트를 못하게 한다. 
 
2. process가 시스템 콜을 하여 커널 모드로 수행 중인데 context switch가 일어난 경우
         
        - 두 프로세스 간의 주소 공간 간에는 데이터 공유가 없음.
        - 하지만 한 프로세스가 시스템 콜을 하여 커널이 수행을 하는 도중 time quantum이 끝나서 다른 프로세스로 cpu가 옮겨감.
        - 결국 다른 프로세스가 커널 주소 공간의 data에 접근하게 됨.
        - 이러면서 race condition이 발생 함.
        
    `solution` : 커널 모드에서 수행 중일 때는 cpu를 preempt하지 않음. 커널 모드에서 사용자 모드로 돌아갈때 preempt함.

3. multiprocessor에서 shared memory 내의 kernel data에서  

        어떤 cpu가 마지막으로 데이터를 저장했는지의 문제로 race condtion이 발생함.
    `solution` : 
    1. 한번에 하나의 cpu만이 커널에 들어갈 수 있게 한다. 
    2. 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlockd을 하는 방법
## The Critical Section Problem
- n개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 `critical section`이 존재
- 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.

> 프로그램적 해결법의 충족조건
- `Mutual Exclusion(상호 배제)`
    - 프로세스 p가 critical section 부분을 수행 중이면 다른 모든 프로세스들은 critical section에 들어가면 안된다.
- `Progress`
    - 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해줘야 한다.
- `Bounded wating`
    - 프로세스가 critical section에 들어가려고 요청한 후 부터 그요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.
- 가정
    - 모든 프로세스의 수행 속도는 0보다 크다.
    - 프로세스들 간의 상대적인 수행 속도는 가정하지 않는다.
## Initial Attempts to Solve Problem
- 2개의 프로세스가 있다고 가정(p0,p1).
- 프로세스들의 일반적인 구조
```
do{
    entry section 
    critical section
    exit section
    remainger section
}while(1);

```
- 프로세스들은 수행의 동기화를 위해 몇몇 변수를 공유할 수 있다. -> synchronization variable
### 1. `Algorithm 1`
         
         - synchronization variable
 
        int turn;
        initially turn  = 0; -> pi은 if(turn == i)일 때 critical section으로 들어갈 수 있다.

  - process p0
      ```
     do{
         while(turn != 0);   //my turn?
         critical section
         turn = 1;   //처리가 끝나면 1을 반환해서 넘김
         remainder section
       }while(1);
     ```

 - mutual exclusion은 만족하지만 progress는 만족하지 못함. 
    - 즉 과잉양보가 발생. 반드시 한번씩 교대로 들어가야만 함(swap turn) 다른 프로세스가 turn값을 나의 값으로 바꿔줘야만 내가 들어갈 수 있음.
    그 중에 cpu를 빼앗겨서 turn값을 바꿔주지 못하면 어떤 프로세스도 critical section에 들어갈 수 없다.
### 2. `Algorithm 2`
- synchronization variable
        
        boolean flag[2];
        initially flag[모두] = false;
        pi는 if(flag[i] == true)일 때 CS에 들어갈 준비가 된다.
        
- process pi
```
do{
    flag[i] = true;   // 준비완료
    while(flag[j]);   // 다른 프로세스있으면 대기
    critical section
    flah[i] = false;  // 다 되면 나감
    ...
}while(1);
```
- mutual exclusion은 만족하지만 progress는 만족하지 못한다.
- 둘 다 2행 까지 수행 후 끊임없이 양보하는 상황 발생.

### 3. `Algorithm 3 (Peterson's Algorithm)`
     
        algorithm 1과 2를 섞어서 사용

      
      
  - process pi
      ```
       do{
       flag[i] = true;  // 준비완료
    trun = j;   // 턴을 상대방 턴으로 바꿈
    while(flag[j] && trun == j);   // 2가지 조건이 만족하면 대기함. 아니면 cs에 들어감.
    critical section
    flag[i] = false;   // 나옴.
    ...
    }while(1);
     ```
- 위의 3가지 조건 모두 만족
- 하지만 `Busy wating = spin lock` (계속 cpu와 memory를 쓰면서 wait)이 발생할 수 있음.

        pi가 cs에 들어가 있는 동안 시간 할당이 끝나서  cpu가 다른 프로세스로 넘어갔을 때, 
        그 프로세스가 cs에 들어가려 할 때 while문에서 벗어나지 못하고 계속 헛돈다. 왜냐면 pi가 while문의 변수를 바꿔줘야 하는데 cpu를 빼앗앗기 때문.
### 4. `Synchronization Hardward`
- **하드웨어** 적으로 test& set(instruction)을 atomic(읽고 쓰는 것을 한 단위로)하게 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결.
- Mutual Exclusion with test & set
 
        synchronization variable:
        boolean lock = false; (= 0)
- process pi
```
do{
    while(test_and_set(lock)); 
    
    /*lock이 
0일때는 while문의 결과 값이 거짓이기 때문에 cs로 들어간다. 동시에 lock을 1로 바꾸면서 lock을 건다.*/

    critical section
    lock. = false;
    ...
}while(1);
```
