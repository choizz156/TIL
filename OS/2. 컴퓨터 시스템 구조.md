# 목차
- [컴퓨터 시스템 구조](#컴퓨터-시스템-구조)
  - [interrupt](#interrupt)
  - [I/O 수행](#io-수행)
  - [I/O Device Controller](#io-device-controller)
  - [Timer](#timer)
  - [mode bit](#mode-bit)
  - [DMA(Direct Memory Access)](#dmadirect-memory-access)
  - [동기식 입출력과 비동기식 입출력](#동기식-입출력과-비동기식-입출력)
  - [저장장치 계층 구조](#저장장치-계층-구조)
  - [프로그램의 실행(메모리 load)](#프로그램의-실행메모리-load)
  - [커널 주소 공간](#커널-주소-공간os)

 
# 컴퓨터 시스템 구조
 
    
  ![](/picture/img.jpg)  
  
  [컴퓨터 시스템 구조][bloglink]

  [bloglink]: https://blog.naver.com/tkfka156/222771817221 "Optional Title here"
      
      
      
## interrupt
    - 진행중인 프로그램이 인터럽트 당하면 그 시점의 레지스터와 프로그램 카운터를 저장한 후 CPU 제어를 인터럽트 처리 루틴에 넘긴다.
    즉, CPU가 프로그램을 실행하고 있을 때, 다른 프로세스를 수행하기 위해 현재 프로그램을 중단하거나 입출력장치에 의해 프로세스가 중단되는 상태이다.

 - 인터럽트
      - interrupt(하드웨어) : 하드웨어가 발생시킨 인터럽트.
      - Trap (소프트트웨어 인터럽트):
        - Exception : 프로그램이 오류를 범한 경우.
        - System call : 프로그램이 커널 함수를 호출하는 경우.

- 인터럽트 관련 용어
     
    - 인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있음.
    - 인터럽트 처리 루틴( = interrupt service runtine) : 해당 인터럽트를 처리하는 커널 함수
 ## I/O 수행
  - 모든 입출력 명령은 우선 명령.
  - 사용자 프로그램은 어떻게 I/O를 하는가?
       1) 시스템 콜 : 사용자 프로그램은 운영체제에게 I/O 요청
       2) trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
       3) 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
       4) 올바른 I/O 요청인지 확인 후 I/O 수행
       5) I/O 완료 시 제어권을 시스템 콜 다음의 명령으로 옮김.
 ## I/O Device Controller
    - 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU.
    - 제어 정보를 위해 control register, status register를 가짐.
    - local buffer(일종의 data register)를 가짐.
   
  - I/O는 실제 디바이스와 local buffer 사이에서 발생.
  - 디바이스 컨트롤러는 I/O가 끝났을 경우 인터럽트로 cpu에 그 사실을 알림.
  
  cf) 디바이스 드라이버(장치구동기) : OS 코드 중 장치별 처리루틴 -> 소프트웨어
  
 ## Timer
    - 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생.
    - 타이머는 매 클럭 틱 때마다 1씩 감소.
    - 타이머 값이 0이 되면 타이머 인터럽트 발생.
    - cpu를 특정 프로그램이 독점하는 것으로 부터 보호.
    - time sharing을 구현하기 위해 널리 이용됨.
    - 현재 시간을 계산하기 위해서도 사용. 
 ## mode bit
    - 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치.
   
   - mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원.
       - 1 사용자 모드 : 사용자 프로그램 수행
       - 0 모니터(커널, 시스템) 모드 : OS 코드 수행
         - 보안을 해칠 수 있는 중여한 명령어는 모니터 모드에서만 수행가능.
         - 인터럽트나 exception 발생시 하드웨어가 mode bit을 0으로 바꿈.
         - 사용자 프로그램에게 cpu를 넘기기 전에 mode bit을 1로 바꿈.
 ## DMA(Direct Memory Access)
    - 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용.
    - cpu의 중재 없이 디바이스 컨트롤러가 디바이스의 buffer storage의 내용을 메모리에 블록단위로 직접 전송.
    - 바이트 단위가 아니라 블럭 단위로 인터럽트를 발생시킴.
 
 ## 동기식 입출력과 비동기식 입출력
    
   - 동기식 입출력(synchoronous I/O)
     - I/O 요청 후 입출력 작업이 안료된 후에야 제어가 사용자 프로그램에 넘어감.
     - 구현 방법 1
       - I/O가 끝날 때까지 cpu를 낭비시킴
       - 매시점 하나의 I/O만 일어날 수 있음
     - 구현 방법 2
       - I/O가 완료될 때까지 해당 프로그램에게서 cpu를 빼앗음.
       - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움.
       - 다른 프로그램에게 cpu를 줌.
   - 비동기식 입출력(asynchoronous I/O)
     - I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감. 
  
   - 두 경우 모두 I/O의 완료는 인터럽트로 알려줌
 
 ![](/picture/비동기식.png) 
 ## 저장장치 계층 구조
 
 ![](/picture/계층구조.png) 
 ## 프로그램의 실행(메모리 load)
    - 프로그램은 실행 파일 형태로 하드디스크에 저장 돼 있다. 그런 실행 파일을 실행하면 메모리로 올라가서 프로세스되고 실행된다.
  - Virtual memory : 프로그램마다 독자적으로 가지고 있는 메모리 주소 공간.
    - stack, data, code로 구성돼 있다.
      - stack : 코드가 함수 구조로 돼 있기 때문에 함수를 호출하거나 리턴할 때 데이터를 쌓았다가 꺼내가는 용도로 사용.
      - data : 변수나 전역 변수 같은 프로그램에서 사용하는 자료 구조를 담고 있다.
      - code : cpu에서 실행할 기계화 코드를 담고 있다.
        
        - 프로그램을 실행시켰을 때 이 주소 공간을 물리적 메모리에 모두 올려 놓는 것은 아니다. 그러면 메모리가 낭비되기 때문에 당장 필요한 부분만 예를 들어 코드가 필요하면 코드만 올려 놓고 그렇지 않은 것은 올리지 않는다. 그리고 코드가 사용이 안되면 메모리에서 쫓겨난다.
  
  - Swap area : 프로그램이 종료되기 전까지 메모리에 당장 필요하지 않은 부분을 스왑 에어리어에다 저장한다. 
  
  - Address transition : 물리적 메모리나 프로그램의 가상 메모리는 0번지부터 시작하는 주소 공간인데, 가상 메모리에서 물리적 메모리로 이동할 때, 주소가 바뀌어야 한다.
    그것을 메모리 주소 변환이라고 하고 하드웨어의 지원을 받는다.  

## 커널 주소 공간(OS)
 
 - code
   - 시스템 콜, 인터럽트 처리 코드
   - 자원 관리를 위한 코드
   - 편리한 서비스 제공을 위한 코드
 - data
   - 운영 체제는 cpu나 메모리, 디스크 같은 하드웨어들을 관리하고 통제하기 때문에 data에는 그것에 대한 자료구조를 하나씩 만들어서 저장하고 있음.
   - 운영 체제는 프로세스를 관리해야 하기 때문에 각 프로그램들이 독자적인 주소공간을 가지고 있지만 이것들을 관리하기 위한 자료구조를 가지고 있음.
 ---------------------------------------------
 ### PCB(process control block)
 
 - 어떤 프로그램에 cpu를 얼마나 썻는지 다음에 누구한테 메모리를 얼마나 줘야 되는지를 결정하기 위한 각 프로그램마다 운영체제가 관리하고 있는 자료구조.
 - 시스템 안에 프로그램이 하나 돌아가면 그 프로그램을 관리하기 위한 자료구자가 운영체제 커널에 하나씩 만들어 진다.
 ----------------------------------------------------------------------

 - stack
   - 운영 체제도 함수 구조로 코드가 짜여져 있기 때문에 함수를 호출하거나 리턴할 때 스택을 사용한다.
   - a 프로그램과 b 프로그램 각각 시스템 콜을 할 수 있기 때문에 사용자 프로그램마다 커널 스택을 따로 두고 있다.
 
 ![](/picture/커널.jpg) 
