## HTTP(HyperText Transfer Protocol)
- HTTP 메시지에 모든 것을 전송
  - HTML, TEXT
  - image, 음성, 영상, 파일
  - JASON, XML(API)
  - 거의 모든 형태의 데이터 전송 가능
  - 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용
- HTTP/1.1을 가장 많이 사용한다. 이 이후는 성능을 개선한 것.
  - 기반 프로토콜
    - TCP : HTTP/1.1, HTTP/2
    - UDP : HTTP/3
    - 현재 HTTP/1.1 주로 사용
  
## 특징
- 클라이언트 서버 구조
  - request response 구조
  - 클라이언트 서버에 요청을 보내고, 응답을 대기
  - 서버가 요청에 대한 결과를 만들어서 응답 
------
## 무상태 프로토콜(Stateless)
  - Stateful, Stateless 차이 
    - `stateful` : 서버가 클라이언트의 이전 상태를 보존(문맥보존).
      - 서버가 바뀌면 상태 정보를 서버에게 미리 알려줘야함.
    - `stateless` : 서버가 클라이언트의 상태를 보존하지 않음. 
      - 중간에 다른 서버로 바뀌어도 된다.
      - 갑자기 클라이언트가 증가해도 서버를 대거 투입할 수 있다.
      - 무상태는 응답 서버를 쉽게 바꿀 수 있다.
      - 스케일 아웃(서버 수평 확장)에 유리하다.
### stateless 한계
  - 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다.
  - 단순한 서비스 소개 화면 같은 경우 무상태로 가능하다.
  - 로그인 같은 경우는 서버가 상태를 유지하고 있어야 한다.(서버가 끊기면 로그인이 끊기도록)
  - 일반적으로 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지
  - 상태 유지는 최소한만 하는 것이 좋음.
  - 전송하는 데이터가 많아진다.

## 비 연결성(Connectionless)

       1. 연결을 유지하는 모델
         - 클라이언트마다 서버 연결을 계속 유지하면서 서버 자원이 소모된다.
       2. 연결을 유지하지 않는 모델 
         - 서버는 연결 유지를 하지 않고 최소한의 자원을 유지한다.
- HTTP는 기본이 연결을 유지하지 않는 모델
- 일반적으로 초 단위 이하의 빠른 속도로 응담
- 실제로 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
- 서버 자원을 효율적으로 사용가능하다.

### 비 연결성 한계와 극복
- TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가
- 웹 브라우저로 사이트를 요청하면 HTML뿐 아니라 자바스크립트,css,추가 이미지 등 수 많은 자원이 함께 다운로드 됨.
- 지금은 HTTP 지속 연결(persistent Connections)로 문제 해결(몇십 초간 연결을 유지)
------
## HTTP 메시지
### HTTP 메시지 구조
| start line  |
|-------------|
| header      |
| 공백          |
| message body |

#### - 시작 라인(start-line)
- 요청 메시지(request-line) : method SP request-target SP HTTP-version CRLF(엔터)
> GET /search?q=hello&hl=ko HTTP/1.1
  - HTTP 메서드 : 서버가 수행해야 할 동작 지정
    - GET, POST, PUT, DELETE
  - 요청 대상(request-target)  : 절대 경로[?query]
  - HTTP 버전 : HTTP:1.1, HTTP/2 등
- 응답 메시지(status-line) : `HTTP-version SP status-code SP reason-phrase CRLF`
> HTTP/1.1 200 OK
  - HTTP 버전
  - HTTP 상태 코드
    - 200 : 성공
    - 400 : 클라이언트 요청 오류
    - 500 : 서버 내부 오류
  - 이유 문구 : 사람이 이해할 수 있는 짧은 상태 코드 설명 글.

#### - 헤더(header)
- header-field : `field-name":" OWS(띄어쓰기 허용) field-value OWS`
>Content-Type(여기는 붙여써야함): text/html...
    - field-name은 대소문자 구분 없음
- 용도
  - HTTP 전송에 필요한 모든 부가 정보
    - 바디의 내용, 메시지 바디의 크기, 압축, 인증 등등
#### - 메시지 바디(message body)
- 실제 전송할 데이터
- HTML 문서, 이미지 등등 byte로 표현할 수 있는 모든 데이터 전송 가능.
---------------------------------------
## HTTP API(Application Programming Interface)
### API URI 설계
> URI를 설계할 때 가장 중요한 것은 `리소스 식별`이다.
- 리소스 의미
  - 행동의 대상, 예를 들어 미네랄을 캐라 -> 미네랄이 리소스이다.
- 리소스를 어떻게 식별?
  - 미네랄이라는 리소스만 식별하면 된다. -> 회원 리소스를 URI에 맵핑
- URI 계층 구조를 활용한다.
  - /members/id 
    - 리소스는 계층 구조상 상위 컬렉션이라고 보고 복수단어 사용을 권장한다.

- 리소스를 식별하고 리소스와 행위를 분리한다.
  - URI는 리소스만 식별.
  - 행동은 HTTP 메서드가 한다.

### HTTP 메서드 종류

#### `GET`
  - 리소스 조회
  - 서버에 전달하고 싶은 데이터는 쿼리 파라미터, 쿼리 스트링을 통해서 전달.
    - **GET /memebers/100 HTTP/1.1**  <- 메시지 전달
    - 서버 도착.
    - 응답 데어터 보냄.
#### `POST`
    - 요청 데이터 처리, 보통 등록하는 데 사용.
    - 메시지 바디로 서버에 요청 데이터 전달.
    - 서버는 요청 데이터 처리.
      - 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.
    - 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용.
    - 메시지 전달 -> 신규 리소스 생성 -> 응답데이터 보냄
> 요청 데이터를 어떻게 처리한단 거야?
><br/>
> 리소스 URI에 POST요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 함. 정해진 것이 없음 
- 예시
  - HTML FORM에 입력한 정보로 회원가입, 주문 등에 사용.
  - 게시판, 뉴스 그룹, 메일링 리스트, 블로그 또는 유사한 기사 그룹에 메시지 게시.
  - 서버가 아직 식별하지 않은 새 리소스 생성. - 신규 주문 생성
  - 기존 자원에 데이터 추가 - 문서 끝에 내용 추가
> 결론
1. 새 리소스 생성(등록),
2. 요청데이터 처리(프로세스를 처리해야 하는 경우), POST /orders/{orderID}/`start-delivery(컨트롤 URI)`
3. 다른 메서드로 처리하기 애매한 경우 에 사용.

#### PUT
- 리소스를 대체
  - 리소스가 있는 경우 **완전히 대체**
  - 리소스가 없는 경우 추가.
- 클라이언트가 리소스를 식별
  - 리소스 위치를 알고 URI를 지정해 주어야 함.
#### PATCH
- 리소스 부분 변경
  - 완전히 대체가 아니라 일부만 변경
- 서버에 이 기능이 없으면 그냥 POST쓰면 됨.

#### DELETE
- 리소스 제거

#### 기타 메서드
- HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환.
- OPTION : 대상 리소스에 대한 통신 가능 옵션(메서드)를 설명(주로 CORS에서 사용).
### HTTP 메서드 속성
- 안전(safe)
  - 호출해도 리소스를 변경하지 않는다.
- 멱등(idempotent)
  - 여러 번 호출해도 결과가 똑같다.
  - GET,PUT,DELETE
  - POST는 멱등 아님!
  - 자동 복구 메커니즘에 활용됨. 
- 캐시가능(Cacheable)
  - 응답 결과 리소스를 캐시해서 사용
    - GET,HEAD,POST,PATCH 캐시 가능
    - 실제로는 GET,HEAD 정도만 사용 (구현이 쉬워서)
  
## HTTP 메서드 활용
- 클라이언트에서 서버로 데이터 전송
  - `쿼리 파라미터`를 통한 데이터 전송
    - GET
    - 주로 정렬 필터(검색어 등) 쓸 떄
- `메시지 바디`를 통한 데이터 전송
  - POST, PUT, PATCH
  - 회원 가입, 상품 주문 리소스 등록,변경 등
### 상황
- 정적 데이터 조회
  - 이미지, 정적 텍스트 문서
  - 조회 GET 사용
  - 정적 데이터는 일반적으로 쿼리 `파라미터 없이 리소스 경로로 단순하게 조회 가능`
- 동적 데이터 조회
  - 주로 검색, 게시판 목록에서 정렬 필터 쓸 때.
  - 조회 조건을 줄여주는 필터, 조회 결과를 정렬하는 정렬 조건에 주로 사용.
  - 조회는 GET을 사용.
  - GET은 `쿼리 파라미터를 사용`해서 데이터를 전달.
#### HTML Form 데이터 전송
  - HTML Form submit시 POST 전송.
    - 회원가입, 상품 주문, 데이터 변경
  - Content_Type: `Application/x-www-form-urlencoded` 사용(데이터가 들어오면 쿼리 파라미터형식으로 바꿔 줌)
    - form의 내용을 메시지 바디를 통해서 전송(key=value, 쿼리 파라미터 형식)
    - 전송 데이터를 url endcoding 처리
  - HTML Form은 GET 전송도 가능
  - Content-Type: `multipart/form-data`
    - 파일 업로드 같은 바이터리 데이터 전송시 사용
    - 다른 종류의 여러 파일과 폼의 내용 함께 전송 가능
  - HTML Form 전송은 GET, POST만 지원.
#### HTTP API 데이터 전송
- 서버 to 서버
  - 백엔드 시스템 통신에서 사용.
- 앱 클라이언트
  - 아이폰, 안드로이드에서 사용.
- 웹 클라이언트
  - HTML에서 Form 전송 대신 자바 스크립트를 통한 통신에 사용(AJAX)
  - React, VueJs같은 웹 클라이너트와 API 통신
- POST, PUT, PATCH: 메시지 바디를 통해 데이터 전송
- GET : 조회, 쿼리 파라미터로 데이터 전달.
- Content-Type: `application/json`을 주로 사용(사실상 표준)
  - TEXT, XML, JSON 등등
## HTTP API 설계 예시
#### HTTP API - 컬렉션
- POST 기반 등록
- 클라이언트는 등록될 리소스의 URI를 모른다.
  - 회원 등록 /memebers -> POST
  - POST /members
- 서버가 새로 등록된 리소스 URI를 생성해 준다
- 컬렉션(Collection)
  - 서버가 관리하는 리소스 디렉토리
  - 서버가 리소스의 URI를 생성하고 관리
  - 여기서 컬렉션은 /members
#### HTTP API - 스토어
- PUT 기반 등록
- 클라이언트가 리소스 URI를 알고 있어야 한다.
  - 파일 등록 /files/{filename} -> PUT
  - PUT /files/star.jpg
- 클라이언트가 직접 리소스의 URI를 지정한다.
- 스토어(Store)
  - 클라이언트가 관리하는 리소스 저장소
  - 클라이언트가 리소스의 URI를 알고 관리해야함.
  - 여기서 스토어는 /files
#### HTML FORM 사용
- HTML FORM은 GET, POST만 지원
- 컨트롤 URI
  - GET, POST만 지원하므로 제약이 있음
  - 제약을 해결하기 위해 동사로 된 리소스 경로 사용
  - POST의 /new, /edit, /delete가 컨트롤 URI
  - HTTP 메서드로 해결하기 애매한 경우 사용(HTTP API 포함)